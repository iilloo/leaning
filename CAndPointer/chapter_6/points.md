#### chapter 6 指针

1. 每一个变量在其存储的位置内都是一串0或1，我们不能通过观察变量存储空间里的位判断变量的类型，其类型是编译器进行判断的；这些位被解释成那种类型取决于它们被使用的方式
2. 值得类型不是一个值得固有特征
3. 变量名字与内存之间的关联不是硬件提供的，是编译器提供的，硬件仍然通过地址访问内存
4. 只声明一个指针不对它进行初始化，之后对该指针得解引用进行赋值，可能会出现段错误，因为该指针指向不确定得空间，该空间未经分配；也有可能指向了一个合法的空间，但原来得值会被修改(错误更难发现)；同时声明一个指针变量不会自动分配任何内存

   *所以建议声明一个指针的同时立即进行初始化(哪怕先初始化为NULL)*
5. NULL指针表示不指向任何东西，可以与0进行对比来判断是否是NULL指针(NULL的实际指向可能不是零，内部与0的对应关系由编译器实现)
6. 对NULL进行解引用操作是非法的，结果因编译器而异(有些机器上会访问0位置)在对指针进行解引用之前应判断是否合法(是否是NULL)
7. 间接访问操作符\*所需要的操作数是个右值 ，所产生的结果是个左值；取址操作符&操作数是左值，结果是右值(因为其结果存贮的位置是随机分配的，不是特定的某个位置)；

   所有变量都是左值(因为该变量标识了内存中的唯一位置(变量作用域内))，加法操作所返回的是个右值
8. 间接访问操作符只能作用于指针类型表达式，\*(int\*)100 = 25 是合法的(*int 100 = 25是非法的)，这是一个指针常量，在访问硬件地址的时候可能会用到
9. \*操作符和&操作符都是从右至左的结合性
10. 数组名指向的是数组的首元素，是一个常量指针，在作为参数传递或存在表达式中时会隐式转换为普通的指针，它与普通的指向数组元素的指针不同的是

    * 用sizeof操作符进行计算得到的是数组整体的字节数大小
    * &取地址符作用时返回指向数组整体的一个指针。
      exp: int a[6] = {0}; int (\*b)[6] = &a ; 变量b就是一个指向数组a整体的指针。类型为int(\*) [6]
11. 数组名+1返回指向下一个位置的数组元素的指针，其向后移动的字节大小与数组中存储的数据类型相关
12. 指针的算数运算只能用于指向同一数组中的元素的指针，用于不同的数组之间，结果是未定义的。

    * 指针+(-) 整数返回的还是指针，指针指向数组最后一个元素紧挨着的后面的一个元素的位置(向后越界一个位置)不违法，但不能对此时的指针进行解引用(违法)，这种“越界”只能是向后的，不能向前
    * 指针-指针 的形式返回两个指针之间的距离(之间相错几个元素，以数组元素的长度为单位)，可以为负数
13. 指针的关系运算只能用于指向同一数组中的元素的指针(!=、==除外，他们可用于任何两个指针;判断两个指针是否相等)
