#### chapter 5 操作符和表达式

1. 有符号数的右位移的右移操作可能是算数位移(右边丢弃，左边空位补符号位)或逻辑位移，有符号数的右移类型由编译器决定

   有符号值的右移位操作是不可移植的 。
2. 但位移操作符的右操作数是负数时，结果是未定义的，由编译器决定
3. value = value 丨 (1 << bit_number) ；表示把value中指定的位置设置为1

   value = value & ~ ( 1 << bit_number ) ; 表示把指定位清0
4. 赋值是表达式的一种，只要允许存在表达式的地方就可以存在赋值表达式

   赋值表达式返回一个右值，其值是=符号左操作符新值的拷贝

   左操作数是左值，右操作数是一个右值
5. a=x=y+3中a和x可能被赋予不同的值(因为当被赋予的值的大小大于该类型的上限时会被截掉多余的部分)

   ~~char~~ ch ; while(( ch != getchar() ) != EOF){;} EOF返回的是一个整数(-1)，所需的位数比字符型所能提供的位数要多，在使用无符号字符作为默认字符集的系统上循环不会终止，应该将ch声明为int型
6. 使用复合型操作符的效率可能比不使用的效率高
7. sizeof()是一个单目操作符，操作数是表达式或变量类型
8. c语言没有bool类型，关系操作符的结果是1或0，1表示关系成立（表达式的结果非零就表示真)
9. 条件操作符(三目操作符) A ？B  :  C      A表达式为真就执行表达式B，否则执行表达式C
10. 逗号操作符将两个或多个表达式分隔开来 。这些表达式自左向右逐个进行求值 ，整个逗号表达式的值是最后那个表达式的值
11. 左值表示这个值在当前作用域下可以表示确定的一个内存空间

    右值仅仅表示这个值的拷贝，因为给右值分配的空间是由编译器随机分配的不能由在该作用域内的已知变量指定

    左值也可以作为右值，但右值不能作为左值
12. 大多数表达式的结果都是右值(类似a[0]、*a除外，他们的结果是左值)
13. c 的整型算术运算总是至少以缺省整型类型的精度来进行的 。 为了获得这个精度 ， 表达式中的字符型和短整型操作数在使用之前被转换为普通整型 ， 这种转换称为整型提升
14. 操作符的操作数类型必须一致，不一致需要进行隐式的寻常算数转换(如果没有强制类型转换)，对于=操作符的左操作数类型提升之后会再次进行值得截短
15. 当整型值转换为 float 型值时 ，有可能损失精度 float 型值仅要求 6 位数字的精度。 如果将一个超过 6 位数字的整型值赋值给一个 float 型变量时 ， 其结果可能只是该整型值的近似值
16. 当 float 型值转换为整型值时 ， 小数部分被舍弃 ，如果浮点数的值过于庞
    大 ， 无法容纳于整型值中 ， 那么其结果将是未定义的 。
17. 逻辑运算符&&和|| 会控制表达式求值得顺序，左表达式满足条件后不会求右表达式的
18. 表达式中建议使用（）号显式确定操作的优先级，P102，操作符的属性表
19. 诸如a\*a + b\*b + c\*c表达式求值的顺序不一定就是先乘法后从左向右的加法运算，可能先计算a\*a和b\*b然后计算他俩的和，之后计算c\*c，最后计算总的和

    具体的计算顺序只要不违背能够控制表达式求值顺序的操作符的规定顺序(, 三目 && ||)，具体的计算顺序由编译器决定

    建议一个运算表达式只执行一次或两次操作，(不要出现连加等诸如此类的操作)
